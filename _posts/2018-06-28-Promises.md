
xx---
layout: post
title: OSGi Promises
description: A gentle introduction into Promises
comments: true
---

At first sight Promises do not fit comfortably in the family of OSGi specifications because they are not a service nor a utility for handling OSGi itself. Until the Promises the OSGi tried to shy away of those. What changed? Well, several services needed an asynchronous completion mechanism. Just have been returned from a sabbatical that I spent with Javascript I proposed to use the Javascript promises as a template. Since there was nothing suitable around at that time we decided to specify a utility for this. The utility is available as a separate library and has not coupling to other OSGi API. I.e. we heavily use it in bnd although bnd itself is (unfortunately) not OSGi based.

## What is a Promise?

The goal of a promise is to reliably execute a number of steps asynchronously. Traditionally we've been doing this with callbacks and listeners. However, anybody that tried a number of steps quickly realizes how complex this is to do reliably because errors, as usual, tend to make our beautiful code quickly become spaghetti. Exceptions relieved us from hard to read source that continuously checked return codes and took different paths. Promises do the same (and much more) for code with asynchronous steps. 

In the most basic form a Promise is a callback:

     Promise<Integer>    promise = foo( 42 );
     promise.thenAccept( System.out::println );

The submit function returns a Promise. We then add a callback when the promise is _is done_. There are two possible ways a Promise becomes done. It can be _resolved_ with a value (including null) or it can _fail_ with an exception. If the Promises resolves, then in the previous example the result is printed. If the Promise fails, then in the previous example the exception is probably logged somewhere but we do not react on the exception, which is not good.

We can use another callback subscription to handle the exceptions:

     promise.then( System.out::println, System.err::println );

A Promise can be done at any time, it is even possible to create promises that are already done ahead of time. Callbacks can be handled at any time, regardless of the state of the Promise. If a callback is added to a resolved Promise, the callback will be fired immediately when registered. 

An interesting, not clearly visible, issue is that a Promise needs access to a background Executor to run the callbacks asynchronously when necessary. 

Therefore, the structure of a Promise looks like:

![image](https://user-images.githubusercontent.com/200494/42022380-81843cf0-7abd-11e8-9e18-b703e8557860.png)

## Creating a Promise

To create a Promise, you need a _Deferred_. A Deferred object is the remote controller of the Promise. It is used to decide when the Promise fails or is resolved, the Promise itself has no API for this. 

    Promise<Integer> foo( int n ) {
       Deferred<Integer> deferred = new Deferred<>();
       
       if ( n > 10) {
           deferred.resolve(n);
       } else {
           deferrred.fail( new Exception("Requires more than 10");
       }
       
       return deferred.getPromise();
    }

Again, the ordering of resolving, failing, or adding callbacks is irrelevant, the result should be the same over time.

## The Promise Factory

Although the next examples could be shown with the Promise and Deferred API, we introduce a bit of extra complexity because it makes many examples so much simpler.

Asynchronous programming requires access to an _Executor_. Although executors are trivially to obtain from the Exectors class, they require careful handling in anything but the most trivial system. Executor Services are shared resources. Many larger systems find out that there are hundreds of (frequently badly configured) Executor Services in the system. Although sharing is often a pain in the ass, Executor Services should really be shared. 

This is why OSGi enRoute registered a shared Executor. Although this Executor can be used, its API is not well aligned with the Promises API. The OSGi 1.1 Promises library therefore has a Promise Factory that manages the background threads while providing a very convenient API to use with Promises.

The following component could provide you with a shared PromiseFactory:

    @Component(service=PromiseFactory.class)
    public PromiseFactoryService extends PromiseFactory {    
      public PromiseFactoryService() {
        super( null, null);
      }
    }

Since there is no need to have OSGi around, you can also create a Promise Factory with:

    PromiseFactory pf = new PromiseFactory(null,null);

This will create a PromiseFactory using the default executor and scheduler.

## Refactoring Deferred Away

When we have a Promise Factory we can make the `foo` example a bit more realistic and run it in the background.

    Promise<Integer> foo( int n ) {
       pf.submit( () -> {
         if ( n > 10)
             return n;
         else
             throw new Exception("Requires more than 10");
      });
    }






## Simple Callback


