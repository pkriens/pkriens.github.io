# Alloy, Software Abstractions

As software practioneer I find that the hardest part of software development is figuring _what_ you need to build. Many colleagues seem upset when they loose a week's worth of coding. Not me. When I've worked on a project for a week, I can recode it in a fraction of the time because I know then exactly _what_ to do. The _how_ is rarely a problem for me, especially nowadays when Google is never too far away.

When you're trying to define what you exactly need to build I need to _feel_ the problem. Coding, making prototypes, is a great way to get this feel for the problem. However, coding is tedious. You need a lot of boiler plate code for even simple problems. Would it not be great if there was a tool that could minimize this exploratory work? Even better, a tool that could not only be used to explore a model but could even verify aspects of it?

Since the 1990's I've been intrigued with formal specifications. However, my experiences with formal specification languages have been quite abysmal. First trying to get your head around a formal specification language is really hard for a pragmatic old school procedural programmer. Second tooling is normally absent or quite horrid.

This changed a couple of years ago when I read [Software Abstractions][1] from Daniel Jackson (the son of Michael for the seniors among my readers). This book introduces a tool called [Alloy][2]. This tool is a pragmatic approach to formal specifications. Though it cannot proof the correctness of a specification in the general case, it can prove an assertion within a limited scope of the specification.

Let's take a look at a very simple model of a Java Map:

    sig Object {}
    sig Map {
      entries : Object -> lone Object
    }

The `sig` keyword defines a type, like a class in Java. The entries represent the table of one object mapping to another object. The `lone` keyword should be read as _optional_. 

Though this looks surprisingly close to a boilerplate-less Java definition it is actually the complete opposite. Where in Java you're not having any instances until you do something, this specification describes the universe and more. It represents all possible Map's of the universe of any possible Object where `entries` contains a mapping for an object or not. 

I had a hard time understanding this until I realised that in Java you are an engineer building state up from nowhere. Formal specifications work the other way around, you start with every possible state and you carve out states with constraints. It is like making a statue. A sculptor removes material while an engineer normally adds material. With formal specifications we're sculpting.

The `entries` is a relation, like a SQL table. This relation is `Object -> Object`, and the full table of this relation looks like the following for 3 atoms O1, O2, and O3:

    O1  O1
    O1  O2
    O1  O3
    O2  O1
    O2  O2
    O2  O3
    O3  O1
    O3  O2
    O3  O3

This means that `entries` can only take on a subset of this table. However, we added the `lone` keyword (optional) to the second part of the relation (the value). This adds a _constraint_ to the `entries` table that throws away any Maps with an `entries` that maps some Object to more than one Object. In Java terms, this would be a _multimap_. We could also model this `1->n` relationship with another constraint, this time on the key:

    entries: Object set -> one Object
    
This also throws away any Map where one key would not either be absent (not in the key set) or or not map to one other Object. Both constraints are identical. 

This `entries` looks like normal Java field, associated with a Map object. It isn't. It is actually a global table! The table has the following format:

	Map -> Object -> Object

It took me forever to get this idea in my head, so I hope you fare better.  The problem is that most usage looks very close to how we use fields in Java: We can map the functions of the Map to an Alloy `fun`.For example, if we want to model the `size` method of our map then it would like like:

    fun Map.size() : Int {
      # this.entries // The `#` represents the cardinality. 
    }

However, in Alloy the dot ('.') is not a field operator but it is a _join_ operator. In the `size` function, if you say `this.entries` you actually join `this` (a member of the Map set) with the `entries` table. This join matches the first column of the table and removes it. So for example, `entries` is the following table:

	m0.o0.o0
	m0.o1.o2
	m0.o2.o0
	m1.o0.o0
	m2.o1.o1
	m1.o2.o0

If we join this table with `m1` then we must first select all rows that start with m1 and then remove the first column:

	m1.o0.o0
	m1.o2.o0

For example, to get the `keySet` and the `values` we can do:

	fun Map.keySet : set Object {
	  this.entries.Object
	}

By joining the `this.entries` table (which is `Object->Object`) with Object, we remove the second column and are left with the keys of the map.

There is a second form of the join which uses the square brackets (`[]`) like an index operation. This is also a join but first calculates the table in front of it, and the joins the table inside the brackets with this result. Like `a[b]` is identical to (b).(a). A tad messy but the nice thing is that now quite often we can use the square brackets as if it is an index. However, realise that it is still a join that returns a set of values. We can use this type of join to get the `values` of the map.

	fun Map.values : set Object {
	  this.entries[Object]
	}

Ok, let's model the get method:

    fun Map.get( key, value : Object ) : Object {
      this.entries[key] = value // is wrong, read further!
    }

However, this is not a correct specifiction because we do not handle the case when the key is not in the `entries`. In Alloy, everything is a _set_. The `entries` are a set of relations and in the `get` function the `key` is a set as well. This brilliant idea means that we do not have to worry about a `null` value in Alloy since this is just an empty set. We also never have to worry about if something is a scalar or a set, everything is a set. A singleton is just a set with one element. 
This is an enormous simplification but it does take time to get used to!

When the Object passed to `get` and it is not in the `entries` then the value of the `this.entries[key]` expression is the empty set. However. We've defined the function as return `Object`, which is a short cut for `one Object`. Ergo, this function fails if it cannot return a single value. Failing does not mean an exception, any state that requires this function to return a value is removed from the universe.

In Java, we do have a `null`, so we therefore need to model it explicitly.

    one sig null extends Object {}
    fun Map.get( key : Object ) : Object {
      one this.entries[key] implies this.entries[key] else null
    }

We define `null` as a singleton and ensure it is in the set `Object` by extending it. (The scary pary about Alloy is that it does resemble Java until it doesn't.) We then modify the `get` function to verify that the key has a mapping. 

One thing that our Java Map also has is the `containsKey` method. So let's add it. Since we've already done the work in `get` let's reuse. (A bad idea as we will later find out.)

    pred Map.containsKey( key : Object ) {
      this.get[key] != null
    }

So far, we've only queried state. One of the big things to get your head around in formal specification is that you cannot _mutate_ state, you can only remove unwanted state. There is no assignment operator, you can only constrain the model. It is therefore not possible to model the Map with mutation. In a formal specification you mutate by selecting defining a transition from one 'thing' to another 'thing' that are both in the overall state. In formal specifications, it is common to model the _before_ state and the _after_ state. The single quote (') is often used to mark an after state.

To model the `put` method we define this transition with a predicate. This predicate succeeds when the method was successful, it fails (is false) when we succeed.

    pred Map.put( m' : Map, key, value, return : Object ) {
	    m'.entries = this.entries ++ key -> value
	    return = this.get[k]
    }

This does look a bit weird. Let's look at the details. The `m'` parameter is the _after_ map. The `key` and the `value` look like Java, but the `return` looks a bit funny for a Java developer. The trick is that later when we are verifying the model with assertions we will try _all_ possible combinations. The predicate will just return false until a combination matches. This indicates that it is valid to call this method. Once the predicate succeeds, we then can validate all invariants. 

The `++` operator adds the relation `key -> value` to the afte state but it also removes any previous mapping from `key` to some object. This maps very well to the Java Map put operation. 

Again, the `=` is _not_ an assignment operator. It just carves out the statespace, it is a constraint, it will remove any solutions from the state space where that constraint is _not_ true.

What we've done so far is specify the semantics of the `size`, `get`, `containsKey`, and `put` methods. We've specified this unambigously since the Alloy language can have only _one_ interpretation. After all, it is a specification language! 

However, how sure are we that this intepretation is the right one? Well, I think anyone that has written specifications can testify that maybe Donald T. can write fantastic specifications without tools but I can't.

Let's add a verification. These are `assertions` in Alloy. We will search through the state space and try to find a Map that does not hold the things we find important. To verify this we _traverse_ the whole state space and search for `put` methods that succeed. When such a method succeed, we verify that any invariants hold and any pre- and post conditions are met. If the method succeeds (for most combinations of parameters it won't), then the _verification_ must succeed. An _assert_ looks for a verification that does not succeed. 

	assert put {
	  all disj m, m' : Map, key, value, return : Object | {      
	    m.put[m',key,value,return] implies {
	      m'.containsKey[key] 
	    }
	  }
	}

Ouch. When we run this assertion we find that it fails. Alloy finds the following counter example:

	put(o,null)
	  before = {}
	  after  = { o->null }

What's going on? Looking at the code we see that I took a shortcut for the `containsKey` method. Instead of properly asserting the presence of the `key` in the `entries` table we called `get` and checked if it was null. However, we can do a `put[o1,null]` and then the value is also `null`. Any `null` value is treated as not present. We therefore have to modify the `containsKey` predicate:

	pred Map.containsKey( key : Object ) {
	  one this.entries[key]
	}

Changing this predicate and running the assertion again shows no more counter examples. This bug was actually done in a slightly more subtle way when I first attempted to write this specification. I also had to discover that I need to add a `null` type. Both errors seem incredibly stupid after working 20 years with Java but I still made them. I found these mistakes quickly because Alloy pointed them out. Since then I've written several other specifications that worked remarkably well. One was a very nasty concurrency problem. During the specification I found a very special case that I'd not taken care off. The code I wrote later was probably the only code I've ever written except `Hello World` where my testing could not find an bugs. 

The only problem I see with using Alloy in anger is that once the specification is written it looks so straightforward that is it is very hard to see why it took so much effort to get there. 

This actually reminds me of an anecdote in one of Daniel Jackson's father's books. He was asked by a manager what his opinion was about his staff. Michael Jackson answered that he thought Tina was quite good. The manager looked a bit concerned and said that they also had had high expectations of her, however, they were not really sure yet. The work she had done so far had turned out to be much simpler then they'd expected ... Actually, Alloy can do that to you too.

   Peter Kriens
   
[1]: https://www.amazon.com/Software-Abstractions-Logic-Language-Analysis/dp/0262528908/ref=sr_1_1?ie=UTF8&qid=1500135292&sr=8-1&keywords=software+abstractions
[2]: http://alloy.mit.edu/alloy/
