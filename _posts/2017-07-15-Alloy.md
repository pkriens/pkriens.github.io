# Alloy, Software Abstractions

As a software practitioner I find that the hardest part of software development is actually figuring _what_ you need to build. Many colleagues seem upset when they loose a week's worth of coding. Not me. When I've worked on a project for a week, I can recode it in a fraction of the time, and get a better result, because I know then exactly _what_ to do. The _how_ is rarely a problem, especially today when Google is never too far away. The _what_ is what takes the time.

When you're trying to define what you exactly need to build I need to _feel_ the problem. Coding, making prototypes, is a great way to get this feel for the problem. However, coding is tedious. You need a lot of boiler plate code for even simple problems. Would it not be great if there was a tool that could minimise this exploratory work? Even better, a tool that could not only be used to explore a model but could even verify aspects of it?

Since the 1990's I've been intrigued with formal specifications. However, my experiences with formal specification languages have been quite abysmal. First trying to get your head around a formal specification language is really hard for a pragmatic old school procedural programmer. Second tooling is normally absent or quite horrid.

This changed a couple of years ago when I read [Software Abstractions][1] from Daniel Jackson (the son of Michael for the more senior among my readers). This book introduces a tool called [Alloy][2]. This tool is a very pragmatic approach to formal specifications. It can prove an assertion but only within a limited scope. This falls short of a full theoretic  proof but it is surprisingly useful in practice. Virtually all bugs I've seen in my life can be demonstrated in a limited scope and Alloy guarantees that those bugs will be found if they exist within that limited scope.

## Types & Tables

To show what Alloy is, let's take a look at a very simple model of a Java Map. Let's start with the keys and values type:

    sig Object {}

The `sig` keyword defines a type, like a class in Java. However, in Alloy it is the name of a _table_ of _atoms_. Actually, every time you use a name in Alloy, which act like variables or types in Java, it is actually a _table of atoms_. In Alloy, singletons, null, collections, methods, and types are all tables under the hood. A table is a _set_ of _tuples_ of _atoms_. 

If we use the curly braces for sets (`{}`) and parentheses ('()') for a tuple then the `sig Object` represents a table with a single column and an infinite number of rows, like:

	{
	  (o1) 
	  (o2)
	  (o..)
	  (o∞)
	}

## Structure

Since we now have a model for Object, we need to define a Java Map to hold the mapped _entries_. A Map is also a table of atoms in Alloy, just like Object. A Map atom identifies one possible Map in the universe of all possible Maps. In our case we need to relate each potential map (identified by a Map atom) to a set of _entries_. If all we have is tables then the entries table should therefore look like:

	{
	  (m1,o1,o1) 
	  (m1,o..,o..) 
	  (m1,o∞,o∞) 
	  (m..,o1,o1) 
	  (m..,o..,o..) 
	  (m∞,o1,o1) 
	  (m∞,o..,o..) 
	  (m∞,o∞,o∞) 
	}

In Alloy, you define this table in a surprisingly familiar looking way:

    sig Map {
      entries : Object -> Object
    }

The `sig Map` defines a `Map` table, holding our Map atoms. However, `entries` does _not_ define a field of a Map, it instead defines a (global!) table called `entries` that looks exactly like our earlier example with `{ (m1,o1,o1) ...}`. 

Notice that `entries` is a table with _3_ columns, the first column is for the the Map atom, the second the key atom, and the third the value atom, or `(map,key,value)` of _type_ `(Map,Object,Object)`. For a Java developer this is confusing since we usually go out of our way to keep things like the `entries` table a local detail of the parent object. However, in Alloy it is actually a global table that can be used anywhere in the specification document. 

## Constraining

In our `entries` table we can have a mapping from any Object to every Object in the universe. In Java, this is not the case. A Java Map can only hold a limited set of keys (memory is so constraining) and each present key can map to only one value. We therefore need to constrain the `entries` table to model this limitation. 

In Alloy, we can constrain the table by placing keywords around the relation (`->`) operator. The `Object set -> one Object` reduces the `entries` table to (a still infinite but smaller) table that can, for any given Object atom, have no mapping or  at most one. That is, the key column of the `entries` table is a subset of the atoms in the `Object` table. However, when an atom is in the key column, there must be exactly one Object in the value column. We can specify this as follows:

    sig Map {
      entries : Object set -> one Object
    }

## Running

Since we've defined a complete model of our universe of Java Maps we can actually run it. We can ask Alloy to show some possible instances of our model. For this, add:

	pred show( map : Map ) {}
	run show for 3

If you run this from the `Execute` menu, you get a diagram. Some are quite boring, like no entries in a Map or even not any Map at all, but you can click on `Next` to see alternatives in the infinite (ok, limited to 6 instances of each atom) universe. For example, the following picture shows a Map with two entries. Object0 is mapped to Object0 and Object1 is mapped to Object1.

![image](https://user-images.githubusercontent.com/200494/28260822-0f698210-6add-11e7-938a-f787f522138d.png)

## Evaluator
If you want to dive deeper into the found solution, click on the `Evaluator` button. This opens a shell where you can look at the data using the Alloy language. For example:

	> Map
	{
	  Map$0
	}
	> Object
	{
	  Object$0,
	  Object$1
	}
	> entries
	{
	  Map$0->Object$0->Object$0,
	  Map$0->Object$1->Object$1
	}
	> Map$0.entries
	{
	  Object$0->Object$0,
	  Object$1->Object$1
	}
	> Map$0.entries.Object
	{
	  Object$0,
	  Object$1
	}
	
_(formatting changed for readability)_

## Scope

The 3 we specified in the `run` phrase is actually the earlier mentioned scope. It states that we will have max 3 Map atoms and max 3 Object atoms. One could think of Alloy iterating over those 6 objects and creating all possible solutions but then we should be prepared to wait a few eons when we get more different types. Even a low number of instances quickly grows into a very large number. This is the definition of the combinatorial explosion and NP complete problems. Fortunately, Alloy uses the specification to prune this state space with a [SAT solver][3] so that answers are usually instantaneous even though the state space is humongous. 

## Sculpting 

Though the Map definition looks surprisingly close to a boilerplate-less Java definitions it is actually the utter opposite. Where in Java you're not having any instances until you do something, this specification models the universe of possible Map instances with every possible combination of Object keys and values. 

I had a hard time understanding this infinite universe model until I realised that in Java you are an engineer building state up from nothing, bit for bit. Formal specifications work the other way around, you start with every possible state in the universe and then you carve out states by specifying constraints. It is like making a statue. A sculptor removes material while an engineer adds material. With formal specifications we're going to sculpt!

It took me quite a bit of time to get my head around this model, so I hope you fare better.  The problem is that most usage looks very close to how we use fields in Java. It is close, but not really. It works intuitive for the simple cases but without properly understanding it, you get lost quickly when constraints become more complex. 

## Joining

Anyway, we've modelled the basics of a Java Map structure. Time to start with the operations. If we want to model the `size` method of our map then we need to define a function. In Alloy, we can use the object oriented style of defining methods:

    fun Map.size() : Int {
      # this.entries // The `#` represents the cardinality, or number of rows, of the table. 
    }

The `this.entries` looks fortunately very intuitive to a Java programmer! There is a Map atom and you access the fields! 

Not. 

In Alloy the dot ('.') is not a field operator but it is a _join_ operator. That is, in Java retrieves some memory at an offset related to the `this` pointer in Alloy we perform a full blown logical join operation. You should use the syntax proximity to Java to initially feel what the dot does but remember that it is infinitely more powerful than accessing a field. 

In the `size` function, if you say `this.entries` you actually join `this` (the atom member of the Map table for wich this function is called) with the `entries` table, which is a `Map->Object->Object` table. That is you join:

	Map . Map->Object->Object

Alloy joins select the _last_ column of the left table with the _first_ column of the right table. In this case our left table is Map and only has one column, however, the join works for any cardinality > 0.

So for example, `entries` is the following table:
	
	{ 
	  (m0,o0,o0)
	  (m0,o1,o2)
	  (m0,o2,o0)
	  (m1,o0,o0)
	  (m2,o1,o1)
	  (m1,o2,o0)
	}

If we join this table with `{(m1)}` then we must first select all rows that start with `m1` in the right table, add any columns to the right of or left table (none in this case) and then remove the matching column. This gives us:

        selected           remove
	m1.o0.o0           o0.o0
	m1.o2.o0           o2.o0

For example, to get the `keySet` of a Map we can define:

	fun Map.keySet : set Object {
	  this.entries.Object
	}

By joining the `this.entries` table (which is `Object->Object`) with Object, we remove the second Object, the value, column, and are left with a one column table with just the keys of the map, the exact definition of the Java `Map.keySet()` method! 

There will be no further selection on the table because the value column can only hold Object and that is always a subset of the Object table. I.e. any atom in the value column is by definition a member of the Object table. So the join result will include all rows.

## Box Join

There is a second _box_ join which uses the square brackets (`[]`) like an index operation. This is a join but changes the evaluation order to make it more intuitive to us coders. 

The box join first calculates the table in front of the start bracket ('['), and then joins the table inside the brackets with this prefixed table. I.e. it flips the selection from the last column to the first column. That is, `a[b]` is identical to `(b).(a)`, where `a` and `b` are tables coming from joins or relations themselves. 

For Java developers this looks quite intuitive. (Unless the expressions gets more complex.) For example, `this.entries[key]` is the same as `key.(this.entries)`. Identical, but the box join is more readable for coders. 

We can thus use this type of box join to get the `values` of the map. Since we want to get the value column we can _index_ it with Object. Since this maps to all the possible keys we match all rows, and since we then remove the key column we're left with a table holding only the keys.

	fun Map.values : set Object {
	  this.entries[Object]
	}

This translates to:

	Object.(this.entries)

Which removes the keys and leaves us with the values. Step by step:

	  left     right           selection           merge        drop
	  (m1) .   (m0,o0,o0)  =   (m1) x (m1,o0,o0)   (m1,o0,o0)   (o0.o0)
	           (m0,o1,o2)      (m1) x (m1,o2,o0)   (m1,o2,o0)   (o2,o0)
	           (m0,o2,o0)
	           (m1,o0,o0)
	           (m2,o1,o1)
	           (m1,o2,o0)

## The Map.get Method

Ok, time for the get method:

    fun Map.get( key : Object ) : Object {
      this.entries[key] // naive and wrong, read further!
    }

When the Object passed to `get` is not in the `this.entries` table then the value of the `this.entries[key]` expression is the empty set. However. We've defined the function as return `Object`, which is a short cut for `one Object`. Ergo, this function fails if it cannot return a single value. Failing does not mean an exception, any state that requires this function to return a value is removed from the universe. However, Java definitely can handle the case when a key has no mapping so we better model it as well. In Java, we have the abuse of the infamous `null`, so we therefore need to model it explicitly.

    one sig null extends Object {}

This adds a specific value to the Object table representing the Java `null` value. That is `null in Object` becomes `true` with this definition. The `one` in front of the `sig` indicates that there is only a single atom representing the case. That is, `null` is a singleton, as it is in Java. 

We can now modify the `get` method. If there is a key present then we want to return the value, otherwise we must return `null`. In Alloy, this looks like
    
    one this.entries[key] implies this.entries[key] else null

One thing that our Java Map also has is the `containsKey` method. So let's add it as well. Since we've already done the work in `get` to detect the presence/absence let's reuse it . (A bad idea as we will later find out.) We'll make it a predicate because it is a function that returns a boolean.

    pred Map.containsKey( key : Object ) {
      this.get[key] != null  // wrong, but oh so widespread!
    }

## Mutating

So far, we've only queried state. One of the big things to get your head around in formal specification is that you cannot _mutate_ state, you can only remove unwanted state from the infinite universe. That is, there is no assignment operator, you can only constrain the model. It is therefore not possible to model the Map with the `put` operation because you need to change its state. In a formal specification you only model mutation by defining a transition by finding a Map that looks like the resulting state. Both Map atoms are in the overall state but are related to a different row in the entries table. 

In formal specifications, it is therefore common to model the _before_ state and the _after_ state with different atoms. The single quote (') is often used to mark an after state. That is, we have for example `map` to hold the _before_ Map and `map'` the _after_ Map.

To model the `put` method we define this transition with a _predicate_. This predicate succeeds when the method was possible for the arguments we've given it, it fails (is false) when we the arguments do not match the operation. That is, we can use the predicate with random arguments but it will indicate when the arguments were ok.

For a predicate, every line is an `and` condition. If a line is false then the whole predicate fails. The `put` method therefore looks like:

    pred Map.put( m' : Map, key, value, return : Object ) {
	    m'.entries = this.entries ++ key -> value
	    return = this.get[k]
    }

This does look a bit weird. Let's look at the details. 

The `m'` parameter is the _after_ map. The `key` and the `value` look like Java, but the `return` looks a bit funny for a Java developer. The trick is that later, when we are verifying the model with assertions, we will try _all_ possible combinations of all parameters. The predicate will return true when a particular combination matches, otherwise it fails. If we succeed, it indicates that `put` method was ok for the given parameters. Once the predicate succeeds, we can therefore then validate all invariants that should hold true. In Java runtime the state of the predicate represent the exceptions the method can throw (if applied well). If the `put` method is called with parameters that the predicate would fail on, then the `put` method should throw an exception. If the `put` method succeeds, the method should not throw an exception. Fortunately, most failures are impossible to do in Java. That is, you cannot specify the return value, it is returned to you.

Back to the details. The `++` operator adds the relation `key -> value` to the after state but it also removes any previous mapping from `key` to any object. This maps very well to the Java Map `put` method. 

And again, the `=` is _not_ an assignment operator. It just carves out the state-space, it is a constraint. The constraint will remove any solutions from the state space where that constraint is _not_ true. In this case, if the predicate is called with a `return` that does not match the `this.get[k]` it just fails. It also rejects any `m'` that does not match the first line of the predicate. Sounds incredibly complex and inefficient for a poor Java developer but it really isn't in the magical world of formal specifications.

## Verification

What we've done so far is to specify the semantics of the `size`, `get`, `containsKey`, `values`, `keySet`, and `put` methods. We've specified this unambiguously since the Alloy language can have only _one_ interpretation. After all, it is a specification language! (Actually, we ignored the Java `equals` semantics to keep things simple.)

However, how sure are we that Alloy's interpretation is the intended one? Anyone that has written specifications can testify that maybe Donald T. can write fantastic specifications without tools but mere mortals SADly can't.

Let's add a verification, these are the `assertions` in Alloy. They will search through the state space and try to find a Map that does not hold the invariants we find important. 

To verify our `put` method we _traverse_ the whole state space and search for `put` methods that succeed. When such a method succeeds, we verify that any invariants hold and any pre- and post conditions are met. If the method succeeds (for most combinations of parameters it won't), then the _verification_ must succeed. An _assert_ looks for a verification that does not succeed. 

One obvious invariant is that when we put a key in a map we expect that the `containsKey` method to be true. Therefore, for every `put` operation that succeeds we require that `containsKey` is true. We therefore iterate over the complete state space and check this assertion:

	assert put {
	  all m, m' : Map, key, value, return : Object | {      
	    m.put[m',key,value,return] implies m'.containsKey[key]
	  }
	}

To run an assertion, you have to add the scope. This looks like:

	check put for 3

When we run this assertion from the `Execution` menu we find that it sadly fails. Alloy finds the following counter example:

	put(o,null)
	  before = {}
	  after  = { o->null }

What's going on? 

Looking at the specification we see that I took a shortcut for the `containsKey` method. Instead of properly asserting the presence of the `key` in the `entries` table we called `get` and checked if it was null. However, we can do a `put[o1,null]` and then the value is `null`, fooling `containsKey`. With our `containsKey`, any `null` value is treated as if there is no mapping. We therefore have to modify the `containsKey` predicate to really test the presence:

	pred Map.containsKey( key : Object ) {
	  one this.entries[key]
	}

We should then change the `get` function to use containsKey so we do not have multiple definitions:

	fun Map.get( key : Object ) : Object {
	  this.containsKey[key] 
	    implies  this.entries[key]
	    else     null
	}

Changing this predicate and running the assertion again shows no more counter examples. 

## What To Verify

What was not always obvious to me was what to assert. After all, in a specification you can often just make something a _fact_. When something is a specified fact it is not useful to assert it. However, specification facts are the onus of the implementer, one would like to minimise them as much as possible. So generally you define the operations; the assertions then verify that the overal state remains as desired.

## Total Specification So Far 

The total specification so far looks like:

	sig Object {}
	one sig null extends Object {}
	sig Map {                      entries : Object -> lone Object }

	fun Map.size() : Int {
	  # this.entries                  
	}
	pred Map.containsKey( key : Object ) {
	  one this.entries[key] 
	}
	fun Map.get( key : Object ) : Object {
	  this.containsKey[key] 
	    implies this.entries[key]
	    else    null
	}
	fun Map.values : set Object {
	  this.entries[Object]
	}
	fun Map.keySet : set Object {
	  this.entries.Object
	}
	pred Map.put( m' : Map,  k, v, r : Object ) {
	  this.get[k] = r
	  m'.entries = this.entries ++ k -> v	
	}
	// verify
	assert put {
	  all disj m, m' : Map, key, value, return : Object {      
	    m.put[m',key,value,return] implies
	      m'.containsKey[key] 
	  }
	}
	check put for 3
	pred show( map : Map ) {}
	run show for 3

## Is this All?

The current model is quite simplistic because its primary value was to show the Alloy language in a way that makes it easy to understand for a Java developer. That said, I am convinced that it would help Java tremendously if we would specify APIs using a formal language. Too often a Javadoc falls woefully short of what a method does, also important, what it does not do. I am also convinced that many of the weird quirks in Java are caused by lack of thinking before coding. One of the main reasons I dived in Alloy this time was my frustration with the Java 9 module specification. I believe it is overly complex and redundant. Properly specifying the model would simplify it and make the redundant parts obvious. I wish I would have been able to use Alloy when we wrote the OSGi specifications. Although I think these specifications are already quite well defined, we could have defined a lot of concepts much more crisp.

However, where specifications really shine is in concurrent problems. With Alloy it is possible to model concurrent problems by making _traces_. In a subsequent blog I hope to show how to construct a model of a flip-flop and a more complex state machine. 

That said, there is a nagging feeling that this is all one my useless efforts because the larger world will never embrace it. In the 90's I wrote report for Ericsson about a management model for cell towers. I used [Z][4] to define this management model. Despite begging I've never been able to get any feedback on it. The big open issue is not if Alloy is useful (it is) but if developers are willing to leave their comfort zone and embrace this powerful technique. Although I think Alloy is quite readable when the specification author tries to keep things readable, it does require quite a bit of effort to learn to write it. Ah well, a bit of a Don Quichot I've always been.

## Conclusion

The `containsKey` bug was actually done in a slightly more subtle way when I first attempted to write a specification for Map. I also had to discover that I need to add a `null` type, did not realise this beforehand. Both errors seem incredibly stupid after working 20 years with Java but I still made them. I found these mistakes quickly because Alloy pointed them out. (Writing a specification for the Map interface is not that useful but it was a good learning example for me.)

Since then I've written several other specifications that worked remarkably well. One was a very nasty concurrency problem where I wanted to minimise the number of `synchronized` blocks. During the specification I found a very special case that I'd not thought off. The code I wrote later was probably the only code I've ever written, except my fourth `Hello World`, where my testing could not find any bugs. 

The only problem I see with using Alloy in anger is that once the specification is written it looks so straightforward that is it is very hard to see why it took so much effort to get there. Why then, not directly code it?

This feeling actually reminds me of an anecdote in one of Daniel Jackson's father's books. He was asked by a manager what his opinion was about the staff. Michael Jackson answered that he thought Allie had impressed him. The manager looked a bit concerned and said that they also had had high expectations of her, however, they were not really sure yet. The work she had done so far had turned out to be very much simpler then they'd expected ... 

   Peter Kriens
   
[1]: https://www.amazon.com/Software-Abstractions-Logic-Language-Analysis/dp/0262528908/ref=sr_1_1?ie=UTF8&qid=1500135292&sr=8-1&keywords=software+abstractions
[2]: http://alloy.mit.edu/alloy/
[3]: https://en.wikipedia.org/wiki/Boolean_satisfiability_problem
[4]: https://en.wikipedia.org/wiki/Z_notation
