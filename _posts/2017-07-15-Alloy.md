# Alloy, Software Abstractions

As a software practioner I find that the hardest part of software development is actually figuring _what_ you need to build. Many colleagues seem upset when they loose a week's worth of coding. Not me. When I've worked on a project for a week, I can recode it in a fraction of the time, and get a better result, because I know then exactly _what_ to do. The _how_ is rarely a problem, especially today when Google is never too far away. The _what_ is what takes the time.

When you're trying to define what you exactly need to build I need to _feel_ the problem. Coding, making prototypes, is a great way to get this feel for the problem. However, coding is tedious. You need a lot of boiler plate code for even simple problems. Would it not be great if there was a tool that could minimize this exploratory work? Even better, a tool that could not only be used to explore a model but could even verify aspects of it?

Since the 1990's I've been intrigued with formal specifications. However, my experiences with formal specification languages have been quite abysmal. First trying to get your head around a formal specification language is really hard for a pragmatic old school procedural programmer. Second tooling is normally absent or quite horrid.

This changed a couple of years ago when I read [Software Abstractions][1] from Daniel Jackson (the son of Michael for the seniors among my readers). This book introduces a tool called [Alloy][2]. This tool is a very pragmatic approach to formal specifications. It can prove an assertion but only within a limited scope of the specification's model. This falls short of a full theorethic  proof but it is suprisingly useful in practice. Virtually all bugs I've seen in my life can be demonstrated in a limited scope and Alloy guarantees you that those bugs will be found if they exist in that limited scope.

## Types & Tables

To show what Alloy is, let's take a look at a very simple model of a Java Map. Let's start with the keys and values type:

    sig Object {}

The `sig` keyword defines a type, like a class in Java. However, in Alloy it is the name of a _table_ of _atoms_. Actually, every time you use a name in Alloy, which act like variables or types in Java, it is actually a table of atoms. A table is a _set_ of _tuples_ of _atoms_. If we use the curly braces for sets (`{}`) and parentheses for a tuple then the `sig Object` represents a table with a single column and an infinite number of rows, like:

	{
	  (o1) 
	  (o2)
	  (o..)
	  (o∞)
	}

## Structure

Since we now model Object, we need to define a Java Map. A Map is of course also a table of atoms identifying any possible map in the universe. However, in our case we need to relate each potential map (identified by an atom) to a set of _entries_. If all we have is tables then the entries table should look like:

	{
	  (m1,o1,o1) 
	  (m1,o..,o..) 
	  (m1,o∞,o∞) 
	  (m..,o1,o1) 
	  (m..,o..,o..) 
	  (m∞,o1,o1) 
	  (m∞,o..,o..) 
	  (m∞,o∞,o∞) 
	}

In Alloy, you define this table in a surprisingly familiar way:

    sig Map {
      entries : Object -> Object
    }

This defines a `Map` table, holding our Map atoms, and it defines a table `entries` that looks like our earlier example. Notice that `entries` is a table with _3_ columns, the first column is for the the Map atom, the second the key, and the third the value, or `(map,key,value)` of _type_ (Map,Object,Object). 

## Constraining

In our shown `entries` table we must have a mapping from any Object in to every Object in the universe. In Java, this is not the case. A Java Map can only hold a limited set of keys and each key can map to only one value. We therefore need to constrain the `entries` to model this. 

In Alloy, we can constrain the table by placing keywords around the relation (`->`) operator. The `Object set -> one Object` reduces the infinite `entries` table to (a still infinite but smaller) table that can, for any given Object atom, have no mapping or  at most one. That is, the key column of the `entries` table is a subset of the atoms in the `Object` table. However, when an atom is in the key column, there must be exactly one Object in the value column. 

    sig Map {
      entries : Object set -> one Object
    }

## Running

Since we've defined a complete model of our universe of Java Maps we can actually run it. We can ask allow to show some possible instances of our model. For this, add:

	pred show( map : Map ) {
	}
	run show for 3

If you run this from the `Execute` menu, you get a diagram. Some are quite boring, like no entries in a map, but you can click on `Next` to see alternatvies.

![image](https://user-images.githubusercontent.com/200494/28260706-9a2291f4-6adc-11e7-8be2-be25c84317e2.png)

## Scultping 

Though the Map definition looks surprisingly close to a boilerplate-less Java definition it is actually the utter opposite. Where in Java you're not having any instances until you do something, this specification models the universe of possible Map instances with every possible combination of Object keys and values. I had a hard time understanding this infinite universe model until I realised that in Java you are an engineer building state up from nothing, bit for bit. Formal specifications work the other way around, you start with every possible state in the universe and then you carve out states by specifying constraints. It is like making a statue. A sculptor removes material while an engineer adds material. With formal specifications we're going to sculpt!

It took me quite a bit of time to get my head around this model, so I hope you fare better.  The problem is that most usage looks very close to how we use fields in Java. It is close, but not really. It works intuitive for the simple cases but without properly understanding it you get lost quickly when constraints become more complex.

## Joining

Anyway, we've modeled the basics of a Java Map, time to start the operations. If we want to model the `size` method of our map then we need to define a function. In Alloy, we can use the object oriented style of defining methods:

    fun Map.size() : Int {
      # this.entries // The `#` represents the cardinality, or number of rows, of the table. 
    }

The `this.entries` looks very intuitive to a Java programmer. There is a map object and you access the fields. Not. In Alloy the dot ('.') is not a field operator but it is a _join_ operator. In the `size` function, if you say `this.entries` you actually join `this` (a member of the Map table) with the `entries` table, which is a `Map->Object->Object` table.

This join matches the first column of the table and then removes that first column. So for example, `entries` is the following table:
	
	{ 
	  (m0,o0,o0)
	  (m0,o1,o2)
	  (m0,o2,o0)
	  (m1,o0,o0)
	  (m2,o1,o1)
	  (m1,o2,o0)
	}

If we join this table with `m1` then we must first select all rows that start with m1 and then remove the first column:

        select             remove
	m1.o0.o0           o0.o0
	m1.o2.o0           o2.o0

For example, to get the `keySet` and the `values` of our map we can do:

	fun Map.keySet : set Object {
	  this.entries.Object
	}

By joining the `this.entries` table (which is `Object->Object`) with Object, we remove the second Object, the value, column, and are left with a 1 column table with the keys of the map. There will be no further selection on the table because the value column can only hold Object and that is always a subset of the Object table. I.e. any atom in the value column is by definition a member of the Object table. So the join result will include all rows.

There is a second _box_ join which uses the square brackets (`[]`) like an index operation. This is a join but changes the evaluation order. It first calculates the table in front of it, and then joins the table inside the brackets with this result. I.e. it flips the selection from the last column to the first column. That is, `a[b]` is identical to `(b).(a)`, where `a` and `b` are tables coming joins or relations themselves. For Java developers this looks quite intuitive. (Unless the expressions get complex.) For example, `this.entries[key]` is the same as `key.(this.entries)`, the first is more readable. A join (box or not) results in (yet) another table. Could be a singleton, or the empty set, but it would still be a table.

We can thus use this type of box join to get the `values` of the map. Since we want to get the value column we can _index_ it with Object. Since this maps to all the possible keys we match all rows, and since we then remove the key column we're left with a table holding only the keys.

	fun Map.values : set Object {
	  this.entries[Object]
	}

## The get Method

Ok, time for the get method:

    fun Map.get( key : Object ) : Object {
      this.entries[key] // is wrong, read further!
    }

When the Object passed to `get` and it is not in the `entries` then the value of the `this.entries[key]` expression is the empty set. However. We've defined the function as return `Object`, which is a short cut for `one Object`. Ergo, this function fails if it cannot return a single value. Failing does not mean an exception, any state that requires this function to return a value is removed from the universe. However, Java definitely can handle the case when a key has no mapping so we better model it as well. In Java, we have the infamous `null`, so we therefore need to model it explicitly.

    one sig null extends Object {}

This adds a specific value to the Object table representing the Java `null`. That is `null in Object` becomes `true`. The `one` in front of the `sig` indicates that there is only a single atom representing the case. That is, `null` is a singleton, as it is in Java. 

We can now modify the `get` method. If there is a key present then we want to return the value, otherwise we must return `null`. In Alloy, this looks like
    
    one this.entries[key] implies this.entries[key] else null

One thing that our Java Map also has is the `containsKey` method. So let's add it. Since we've already done the work in `get` let's reuse it and make a _predicate_. (A bad idea as we will later find out.) A predicate is a function that returns a boolean.

    pred Map.containsKey( key : Object ) {
      this.get[key] != null  // wrong!
    }

## Mutating

So far, we've only queried state. One of the big things to get your head around in formal specification is that you cannot _mutate_ state, you can only remove unwanted state from the infinite universe. That is, there is no assignment operator, you can only constrain the model. It is therefore not possible to model the Map with mutation. In a formal specification you mutate by defining a transition from one 'thing' to another 'thing'. Both 'things' are overall state. In formal specifications, it is common to model the _before_ state and the _after_ state. The single quote (') is often used to mark an after state.

To model the `put` method we define this transition with a predicate. This predicate succeeds when the method was possible for the arguments, it fails (is false) when we the arguments do not match the operation. That is, we cann use the predicate with random arguments but it will indicate when the arguments were ok.

For a predicate, every line is an `and` condition. If a line is false then the whole predicate fails.

    pred Map.put( m' : Map, key, value, return : Object ) {
	    m'.entries = this.entries ++ key -> value
	    return = this.get[k]
    }

This does look a bit weird. Let's look at the details. The `m'` parameter is the _after_ map. The `key` and the `value` look like Java, but the `return` looks a bit funny for a Java developer. The trick is that later when we are verifying the model with assertions we will try _all_ possible combinations of all parameters. The predicate will just return false until a combination matches. This indicates that it is valid to call this method. Once the predicate succeeds, we then can validate all invariants. 

The `++` operator adds the relation `key -> value` to the after state but it also removes any previous mapping from `key` to some object. This maps very well to the Java Map put operation. 

Again, the `=` is _not_ an assignment operator. It just carves out the statespace, it is a constraint, it will remove any solutions from the state space where that constraint is _not_ true. 

## Verification

What we've done so far is specify the semantics of the `size`, `get`, `containsKey`, and `put` methods. We've specified this unambigously since the Alloy language can have only _one_ interpretation. After all, it is a specification language! 

However, how sure are we that Alloy's intepretation is the intended one? Well, I think anyone that has written specifications can testify that maybe Donald T. can write fantastic specifications without tools but mere mortals can't.

Let's add a verification. These are `assertions` in Alloy. We will search through the state space and try to find a Map that does not hold the invariants we find important. To verify this we _traverse_ the whole state space and search for `put` methods that succeed. When such a method succeeds, we verify that any invariants hold and any pre- and post conditions are met. If the method succeeds (for most combinations of parameters it won't), then the _verification_ must succeed. An _assert_ looks for a verification that does not succeed. 

One invariant is that when put a key in a map we expect that the `containsKey` method is true. Therefore, for every `put` operation that succeeds we can expect that `containsKey` is true. We therefore iterate over the complete state space and check this assertion:

	assert put {
	  all m, m' : Map, key, value, return : Object | {      
	    m.put[m',key,value,return] implies m'.containsKey[key]
	  }
	}

To run an assertion, you have to add the scope. This looks like:

	check put for 5

When we run this assertion from the menu we find that it unfortunately fails. Alloy finds the following counter example:

	put(o,null)
	  before = {}
	  after  = { o->null }

What's going on? Looking at the code we see that I took a shortcut for the `containsKey` method. Instead of properly asserting the presence of the `key` in the `entries` table we called `get` and checked if it was null. However, we can do a `put[o1,null]` and then the value is also `null`. With our `containsKey`, any `null` value is treated as if there is no mapping. We therefore have to modify the `containsKey` predicate:

	pred Map.containsKey( key : Object ) {
	  one this.entries[key]
	}

Changing this predicate and running the assertion again shows no more counter examples. 

## Conclusion

This bug was actually done in a slightly more subtle way when I first attempted to write this specification. I also had to discover that I need to add a `null` type. Both errors seem incredibly stupid after working 20 years with Java but I still made them. I found these mistakes quickly because Alloy pointed them out. (Writing a specification for the Map interface was a good learning example.)

Since then I've written several other specifications that worked remarkably well. One was a very nasty concurrency problem. During the specification I found a very special case that I'd not thought off. The code I wrote later was probably the only code I've ever written except `Hello World` where my testing could not find an bugs. 

The only problem I see with using Alloy in anger is that once the specification is written it looks so straightforward that is it is very hard to see why it took so much effort to get there. Why then, not directly code it?

This feeling actually reminds me of an anecdote in one of Daniel Jackson's father's books. He was asked by a manager what his opinion was about his staff. Michael Jackson answered that he thought Tina was quite good. The manager looked a bit concerned and said that they also had had high expectations of her, however, they were not really sure yet. The work she had done so far had turned out to be much simpler then they'd expected ... Actually, Alloy can do that to you too.

   Peter Kriens
   
[1]: https://www.amazon.com/Software-Abstractions-Logic-Language-Analysis/dp/0262528908/ref=sr_1_1?ie=UTF8&qid=1500135292&sr=8-1&keywords=software+abstractions
[2]: http://alloy.mit.edu/alloy/
